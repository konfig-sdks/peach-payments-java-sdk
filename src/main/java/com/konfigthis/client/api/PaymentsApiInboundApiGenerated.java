/*
 * Payments API inbound
 * The Payments API enables you to do a custom integration with Peach Payments and thereby support multiple payment methods.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@peachpayments.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.Address;
import com.konfigthis.client.model.Authentication;
import com.konfigthis.client.model.Cart;
import com.konfigthis.client.model.Customer;
import com.konfigthis.client.model.EPResponse;
import com.konfigthis.client.model.MerchantTransactionIdStatusResponse;
import com.konfigthis.client.model.PaymentBrand;
import com.konfigthis.client.model.PaymentRequest;
import com.konfigthis.client.model.PaymentType;
import com.konfigthis.client.model.REResponse;
import com.konfigthis.client.model.RefundPaymentType;
import com.konfigthis.client.model.RefundRequest;
import com.konfigthis.client.model.Shopify;
import com.konfigthis.client.model.TransactionIdStatusResponse;
import java.net.URI;
import com.konfigthis.client.model.VirtualAccount;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class PaymentsApiInboundApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PaymentsApiInboundApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public PaymentsApiInboundApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call initiateDebitTransactionCall(PaymentRequest paymentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = paymentRequest;

        // create path and map variables
        String localVarPath = "/payments";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call initiateDebitTransactionValidateBeforeCall(PaymentRequest paymentRequest, final ApiCallback _callback) throws ApiException {
        return initiateDebitTransactionCall(paymentRequest, _callback);

    }


    private ApiResponse<EPResponse> initiateDebitTransactionWithHttpInfo(PaymentRequest paymentRequest) throws ApiException {
        okhttp3.Call localVarCall = initiateDebitTransactionValidateBeforeCall(paymentRequest, null);
        Type localVarReturnType = new TypeToken<EPResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call initiateDebitTransactionAsync(PaymentRequest paymentRequest, final ApiCallback<EPResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = initiateDebitTransactionValidateBeforeCall(paymentRequest, _callback);
        Type localVarReturnType = new TypeToken<EPResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class InitiateDebitTransactionRequestBuilder {
        private final Authentication authentication;
        private final String merchantTransactionId;
        private final String amount;
        private final String currency;
        private final PaymentBrand paymentBrand;
        private final PaymentType paymentType;
        private VirtualAccount virtualAccount;
        private Address shipping;
        private Address billing;
        private Shopify shopify;
        private Customer customer;
        private Cart cart;
        private String merchantInvoiceId;
        private URI shopperResultUrl;

        private InitiateDebitTransactionRequestBuilder(Authentication authentication, String merchantTransactionId, String amount, String currency, PaymentBrand paymentBrand, PaymentType paymentType) {
            this.authentication = authentication;
            this.merchantTransactionId = merchantTransactionId;
            this.amount = amount;
            this.currency = currency;
            this.paymentBrand = paymentBrand;
            this.paymentType = paymentType;
        }

        /**
         * Set virtualAccount
         * @param virtualAccount  (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder virtualAccount(VirtualAccount virtualAccount) {
            this.virtualAccount = virtualAccount;
            return this;
        }
        
        /**
         * Set shipping
         * @param shipping  (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder shipping(Address shipping) {
            this.shipping = shipping;
            return this;
        }
        
        /**
         * Set billing
         * @param billing  (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder billing(Address billing) {
            this.billing = billing;
            return this;
        }
        
        /**
         * Set shopify
         * @param shopify  (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder shopify(Shopify shopify) {
            this.shopify = shopify;
            return this;
        }
        
        /**
         * Set customer
         * @param customer  (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder customer(Customer customer) {
            this.customer = customer;
            return this;
        }
        
        /**
         * Set cart
         * @param cart  (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder cart(Cart cart) {
            this.cart = cart;
            return this;
        }
        
        /**
         * Set merchantInvoiceId
         * @param merchantInvoiceId The merchant&#39;s invoice ID. (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder merchantInvoiceId(String merchantInvoiceId) {
            this.merchantInvoiceId = merchantInvoiceId;
            return this;
        }
        
        /**
         * Set shopperResultUrl
         * @param shopperResultUrl The Payments API redirects the user to this URL after processing the payment request. (optional)
         * @return InitiateDebitTransactionRequestBuilder
         */
        public InitiateDebitTransactionRequestBuilder shopperResultUrl(URI shopperResultUrl) {
            this.shopperResultUrl = shopperResultUrl;
            return this;
        }
        
        /**
         * Build call for initiateDebitTransaction
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            PaymentRequest paymentRequest = buildBodyParams();
            return initiateDebitTransactionCall(paymentRequest, _callback);
        }

        private PaymentRequest buildBodyParams() {
            PaymentRequest paymentRequest = new PaymentRequest();
            paymentRequest.authentication(this.authentication);
            paymentRequest.merchantTransactionId(this.merchantTransactionId);
            paymentRequest.amount(this.amount);
            paymentRequest.currency(this.currency);
            paymentRequest.paymentBrand(this.paymentBrand);
            paymentRequest.paymentType(this.paymentType);
            paymentRequest.virtualAccount(this.virtualAccount);
            paymentRequest.shipping(this.shipping);
            paymentRequest.billing(this.billing);
            paymentRequest.shopify(this.shopify);
            paymentRequest.customer(this.customer);
            paymentRequest.cart(this.cart);
            paymentRequest.merchantInvoiceId(this.merchantInvoiceId);
            paymentRequest.shopperResultUrl(this.shopperResultUrl);
            return paymentRequest;
        }

        /**
         * Execute initiateDebitTransaction request
         * @return EPResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public EPResponse execute() throws ApiException {
            PaymentRequest paymentRequest = buildBodyParams();
            ApiResponse<EPResponse> localVarResp = initiateDebitTransactionWithHttpInfo(paymentRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute initiateDebitTransaction request with HTTP info returned
         * @return ApiResponse&lt;EPResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<EPResponse> executeWithHttpInfo() throws ApiException {
            PaymentRequest paymentRequest = buildBodyParams();
            return initiateDebitTransactionWithHttpInfo(paymentRequest);
        }

        /**
         * Execute initiateDebitTransaction request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<EPResponse> _callback) throws ApiException {
            PaymentRequest paymentRequest = buildBodyParams();
            return initiateDebitTransactionAsync(paymentRequest, _callback);
        }
    }

    /**
     * Payment
     * Initiate a debit transaction.  Certain parameters are mandatory for specific payment methods and certain parameters act differently depending on the payment method.   - For 1Voucher, &#x60;customer.mobile&#x60; (the customer&#39;s phone number for receiving change vouchers and refunds) and &#x60;virtualAccount.password&#x60; (the voucher PIN) are mandatory. - For M-PESA, &#x60;virtualAccount.accountId&#x60; (the customer&#39;s 12-digit phone number) is mandatory. M-PESA only accepts integer amounts, not decimals, so round up your amount. - For blink by Emtel and MCB Juice, &#x60;virtualAccount.accountId&#x60; (the customer&#39;s 8-digit phone number) is mandatory. - For Mobicred, &#x60;virtualAccount.accountId&#x60; (the customer&#39;s Mobicred email address) and &#x60;virtualAccount.password&#x60; (the customer&#39;s Mobicred password) are mandatory. - For Capitec Pay, &#x60;virtualAccount.type&#x60; (the customer&#39;s identifier type; &#x60;IDNUMBER&#x60;, &#x60;CELLPHONE&#x60;, or &#x60;ACCOUNTNUMBER&#x60;) and &#x60;virtualAccount.accountId&#x60; (the customer&#39;s 13-digit ID number, 10-digit phone number starting with &#x60;0&#x60;, or up-to 64-digit, alphanumeric bank account number) are mandatory. High-risk merchants must provide the verified &#x60;IDNUMBER&#x60; and cannot use the &#x60;CELLPHONE&#x60; or &#x60;ACCOUNTNUMBER&#x60; account types. - For EFTsecure, Payflex, ZeroPay, FinChoicePay, Scan to Pay, M-PESA, blink by Emtel, Mobicred, Capitec Pay, Nebank Direct EFT, and MCB Juice, the &#x60;shopperResultUrl&#x60; is mandatory.  For more information, see the [documentation](https://developer.peachpayments.com/docs/payments-api-flows#payment-flow) and for sample calls, see our [public Postman collection](https://www.postman.com/peachpayments/workspace/peach-payments-public-workspace/request/13324425-693c4b18-dad5-4b6f-aeb0-99bc28b94812). 
     * @return InitiateDebitTransactionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
     </table>
     */
    public InitiateDebitTransactionRequestBuilder initiateDebitTransaction(Authentication authentication, String merchantTransactionId, String amount, String currency, PaymentBrand paymentBrand, PaymentType paymentType) throws IllegalArgumentException {
        if (authentication == null) throw new IllegalArgumentException("\"authentication\" is required but got null");
        if (merchantTransactionId == null) throw new IllegalArgumentException("\"merchantTransactionId\" is required but got null");
            

        if (amount == null) throw new IllegalArgumentException("\"amount\" is required but got null");
            

        if (currency == null) throw new IllegalArgumentException("\"currency\" is required but got null");
            

        if (paymentBrand == null) throw new IllegalArgumentException("\"paymentBrand\" is required but got null");
        if (paymentType == null) throw new IllegalArgumentException("\"paymentType\" is required but got null");
        return new InitiateDebitTransactionRequestBuilder(authentication, merchantTransactionId, amount, currency, paymentBrand, paymentType);
    }
    private okhttp3.Call queryTransactionByIdCall(String uniqueId, String authenticationEntityId, String authenticationUserId, String authenticationPassword, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/payments/{uniqueId}"
            .replace("{" + "uniqueId" + "}", localVarApiClient.escapeString(uniqueId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (authenticationEntityId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authentication.entityId", authenticationEntityId));
        }

        if (authenticationUserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authentication.userId", authenticationUserId));
        }

        if (authenticationPassword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authentication.password", authenticationPassword));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryTransactionByIdValidateBeforeCall(String uniqueId, String authenticationEntityId, String authenticationUserId, String authenticationPassword, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uniqueId' is set
        if (uniqueId == null) {
            throw new ApiException("Missing the required parameter 'uniqueId' when calling queryTransactionById(Async)");
        }

        // verify the required parameter 'authenticationEntityId' is set
        if (authenticationEntityId == null) {
            throw new ApiException("Missing the required parameter 'authenticationEntityId' when calling queryTransactionById(Async)");
        }

        // verify the required parameter 'authenticationUserId' is set
        if (authenticationUserId == null) {
            throw new ApiException("Missing the required parameter 'authenticationUserId' when calling queryTransactionById(Async)");
        }

        // verify the required parameter 'authenticationPassword' is set
        if (authenticationPassword == null) {
            throw new ApiException("Missing the required parameter 'authenticationPassword' when calling queryTransactionById(Async)");
        }

        return queryTransactionByIdCall(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword, _callback);

    }


    private ApiResponse<TransactionIdStatusResponse> queryTransactionByIdWithHttpInfo(String uniqueId, String authenticationEntityId, String authenticationUserId, String authenticationPassword) throws ApiException {
        okhttp3.Call localVarCall = queryTransactionByIdValidateBeforeCall(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword, null);
        Type localVarReturnType = new TypeToken<TransactionIdStatusResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call queryTransactionByIdAsync(String uniqueId, String authenticationEntityId, String authenticationUserId, String authenticationPassword, final ApiCallback<TransactionIdStatusResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryTransactionByIdValidateBeforeCall(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword, _callback);
        Type localVarReturnType = new TypeToken<TransactionIdStatusResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class QueryTransactionByIdRequestBuilder {
        private final String uniqueId;
        private final String authenticationEntityId;
        private final String authenticationUserId;
        private final String authenticationPassword;

        private QueryTransactionByIdRequestBuilder(String uniqueId, String authenticationEntityId, String authenticationUserId, String authenticationPassword) {
            this.uniqueId = uniqueId;
            this.authenticationEntityId = authenticationEntityId;
            this.authenticationUserId = authenticationUserId;
            this.authenticationPassword = authenticationPassword;
        }

        /**
         * Build call for queryTransactionById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return queryTransactionByIdCall(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword, _callback);
        }


        /**
         * Execute queryTransactionById request
         * @return TransactionIdStatusResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public TransactionIdStatusResponse execute() throws ApiException {
            ApiResponse<TransactionIdStatusResponse> localVarResp = queryTransactionByIdWithHttpInfo(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute queryTransactionById request with HTTP info returned
         * @return ApiResponse&lt;TransactionIdStatusResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TransactionIdStatusResponse> executeWithHttpInfo() throws ApiException {
            return queryTransactionByIdWithHttpInfo(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword);
        }

        /**
         * Execute queryTransactionById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TransactionIdStatusResponse> _callback) throws ApiException {
            return queryTransactionByIdAsync(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword, _callback);
        }
    }

    /**
     * Query a transaction by transaction ID
     * Query the status of a transaction using the Peach Payments unique ID.  For more information, see the [documentation](https://developer.peachpayments.com/docs/payments-api-flows#transaction-status-flow). 
     * @param uniqueId The Peach Payments unique ID for the transaction. (required)
     * @param authenticationEntityId Authentication entityId. (required)
     * @param authenticationUserId Authentication userId. (required)
     * @param authenticationPassword Authentication password. (required)
     * @return QueryTransactionByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
     </table>
     */
    public QueryTransactionByIdRequestBuilder queryTransactionById(String uniqueId, String authenticationEntityId, String authenticationUserId, String authenticationPassword) throws IllegalArgumentException {
        if (uniqueId == null) throw new IllegalArgumentException("\"uniqueId\" is required but got null");
            

        if (authenticationEntityId == null) throw new IllegalArgumentException("\"authenticationEntityId\" is required but got null");
            

        if (authenticationUserId == null) throw new IllegalArgumentException("\"authenticationUserId\" is required but got null");
            

        if (authenticationPassword == null) throw new IllegalArgumentException("\"authenticationPassword\" is required but got null");
            

        return new QueryTransactionByIdRequestBuilder(uniqueId, authenticationEntityId, authenticationUserId, authenticationPassword);
    }
    private okhttp3.Call refundTransactionCall(String uniqueId, RefundRequest refundRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = refundRequest;

        // create path and map variables
        String localVarPath = "/payments/{uniqueId}"
            .replace("{" + "uniqueId" + "}", localVarApiClient.escapeString(uniqueId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call refundTransactionValidateBeforeCall(String uniqueId, RefundRequest refundRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uniqueId' is set
        if (uniqueId == null) {
            throw new ApiException("Missing the required parameter 'uniqueId' when calling refundTransaction(Async)");
        }

        return refundTransactionCall(uniqueId, refundRequest, _callback);

    }


    private ApiResponse<REResponse> refundTransactionWithHttpInfo(String uniqueId, RefundRequest refundRequest) throws ApiException {
        okhttp3.Call localVarCall = refundTransactionValidateBeforeCall(uniqueId, refundRequest, null);
        Type localVarReturnType = new TypeToken<REResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call refundTransactionAsync(String uniqueId, RefundRequest refundRequest, final ApiCallback<REResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = refundTransactionValidateBeforeCall(uniqueId, refundRequest, _callback);
        Type localVarReturnType = new TypeToken<REResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class RefundTransactionRequestBuilder {
        private final Authentication authentication;
        private final String amount;
        private final String currency;
        private final RefundPaymentType paymentType;
        private final String uniqueId;

        private RefundTransactionRequestBuilder(Authentication authentication, String amount, String currency, RefundPaymentType paymentType, String uniqueId) {
            this.authentication = authentication;
            this.amount = amount;
            this.currency = currency;
            this.paymentType = paymentType;
            this.uniqueId = uniqueId;
        }

        /**
         * Build call for refundTransaction
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            RefundRequest refundRequest = buildBodyParams();
            return refundTransactionCall(uniqueId, refundRequest, _callback);
        }

        private RefundRequest buildBodyParams() {
            RefundRequest refundRequest = new RefundRequest();
            refundRequest.authentication(this.authentication);
            refundRequest.amount(this.amount);
            refundRequest.currency(this.currency);
            refundRequest.paymentType(this.paymentType);
            return refundRequest;
        }

        /**
         * Execute refundTransaction request
         * @return REResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public REResponse execute() throws ApiException {
            RefundRequest refundRequest = buildBodyParams();
            ApiResponse<REResponse> localVarResp = refundTransactionWithHttpInfo(uniqueId, refundRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute refundTransaction request with HTTP info returned
         * @return ApiResponse&lt;REResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<REResponse> executeWithHttpInfo() throws ApiException {
            RefundRequest refundRequest = buildBodyParams();
            return refundTransactionWithHttpInfo(uniqueId, refundRequest);
        }

        /**
         * Execute refundTransaction request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<REResponse> _callback) throws ApiException {
            RefundRequest refundRequest = buildBodyParams();
            return refundTransactionAsync(uniqueId, refundRequest, _callback);
        }
    }

    /**
     * Refund
     * Refund a successful debit transaction. You can only refund [certain payment methods](https://developer.peachpayments.com/docs/pp-payment-methods).  For more information, see the [documentation](https://developer.peachpayments.com/docs/payments-api-flows#refund-flow). 
     * @param uniqueId The Peach Payments unique ID of the original debit transaction. (required)
     * @return RefundTransactionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
     </table>
     */
    public RefundTransactionRequestBuilder refundTransaction(Authentication authentication, String amount, String currency, RefundPaymentType paymentType, String uniqueId) throws IllegalArgumentException {
        if (authentication == null) throw new IllegalArgumentException("\"authentication\" is required but got null");
        if (amount == null) throw new IllegalArgumentException("\"amount\" is required but got null");
            

        if (currency == null) throw new IllegalArgumentException("\"currency\" is required but got null");
            

        if (paymentType == null) throw new IllegalArgumentException("\"paymentType\" is required but got null");
        if (uniqueId == null) throw new IllegalArgumentException("\"uniqueId\" is required but got null");
            

        return new RefundTransactionRequestBuilder(authentication, amount, currency, paymentType, uniqueId);
    }
    private okhttp3.Call statusCall(String authenticationUserId, String authenticationPassword, String authenticationEntityId, String merchantTransactionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/payments";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (authenticationUserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authentication.userId", authenticationUserId));
        }

        if (authenticationPassword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authentication.password", authenticationPassword));
        }

        if (authenticationEntityId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authentication.entityId", authenticationEntityId));
        }

        if (merchantTransactionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("merchantTransactionId", merchantTransactionId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "BearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call statusValidateBeforeCall(String authenticationUserId, String authenticationPassword, String authenticationEntityId, String merchantTransactionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authenticationUserId' is set
        if (authenticationUserId == null) {
            throw new ApiException("Missing the required parameter 'authenticationUserId' when calling status(Async)");
        }

        // verify the required parameter 'authenticationPassword' is set
        if (authenticationPassword == null) {
            throw new ApiException("Missing the required parameter 'authenticationPassword' when calling status(Async)");
        }

        // verify the required parameter 'authenticationEntityId' is set
        if (authenticationEntityId == null) {
            throw new ApiException("Missing the required parameter 'authenticationEntityId' when calling status(Async)");
        }

        // verify the required parameter 'merchantTransactionId' is set
        if (merchantTransactionId == null) {
            throw new ApiException("Missing the required parameter 'merchantTransactionId' when calling status(Async)");
        }

        return statusCall(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId, _callback);

    }


    private ApiResponse<MerchantTransactionIdStatusResponse> statusWithHttpInfo(String authenticationUserId, String authenticationPassword, String authenticationEntityId, String merchantTransactionId) throws ApiException {
        okhttp3.Call localVarCall = statusValidateBeforeCall(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId, null);
        Type localVarReturnType = new TypeToken<MerchantTransactionIdStatusResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call statusAsync(String authenticationUserId, String authenticationPassword, String authenticationEntityId, String merchantTransactionId, final ApiCallback<MerchantTransactionIdStatusResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = statusValidateBeforeCall(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId, _callback);
        Type localVarReturnType = new TypeToken<MerchantTransactionIdStatusResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class StatusRequestBuilder {
        private final String authenticationUserId;
        private final String authenticationPassword;
        private final String authenticationEntityId;
        private final String merchantTransactionId;

        private StatusRequestBuilder(String authenticationUserId, String authenticationPassword, String authenticationEntityId, String merchantTransactionId) {
            this.authenticationUserId = authenticationUserId;
            this.authenticationPassword = authenticationPassword;
            this.authenticationEntityId = authenticationEntityId;
            this.merchantTransactionId = merchantTransactionId;
        }

        /**
         * Build call for status
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return statusCall(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId, _callback);
        }


        /**
         * Execute status request
         * @return MerchantTransactionIdStatusResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public MerchantTransactionIdStatusResponse execute() throws ApiException {
            ApiResponse<MerchantTransactionIdStatusResponse> localVarResp = statusWithHttpInfo(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute status request with HTTP info returned
         * @return ApiResponse&lt;MerchantTransactionIdStatusResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MerchantTransactionIdStatusResponse> executeWithHttpInfo() throws ApiException {
            return statusWithHttpInfo(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId);
        }

        /**
         * Execute status request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MerchantTransactionIdStatusResponse> _callback) throws ApiException {
            return statusAsync(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId, _callback);
        }
    }

    /**
     * Query a transaction by merchantTransactionId
     * Query the status of a transaction using the merchantTransactionId. Could return multiple results.  For more information, see the [documentation](https://developer.peachpayments.com/docs/payments-api-flows#transaction-status-flow). 
     * @param authenticationUserId  (required)
     * @param authenticationPassword  (required)
     * @param authenticationEntityId  (required)
     * @param merchantTransactionId  (required)
     * @return StatusRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
     </table>
     */
    public StatusRequestBuilder status(String authenticationUserId, String authenticationPassword, String authenticationEntityId, String merchantTransactionId) throws IllegalArgumentException {
        if (authenticationUserId == null) throw new IllegalArgumentException("\"authenticationUserId\" is required but got null");
            

        if (authenticationPassword == null) throw new IllegalArgumentException("\"authenticationPassword\" is required but got null");
            

        if (authenticationEntityId == null) throw new IllegalArgumentException("\"authenticationEntityId\" is required but got null");
            

        if (merchantTransactionId == null) throw new IllegalArgumentException("\"merchantTransactionId\" is required but got null");
            

        return new StatusRequestBuilder(authenticationUserId, authenticationPassword, authenticationEntityId, merchantTransactionId);
    }
}
